# Практическая работа №2
## Этап 1. Переход к SystemVerilog
Ниже представлен код модулей на языке SystemVerilog, переведённый из системной модели на языке C++.
### Модуль нейропроцессора

```systemverilog
/*
 * Нейронная сеть для inference
 * Архитектура: 6 ? 32 ? 16 ? 2
 * Веса из network_weights.txt (scale=100000)
 */

module neural_inference_sv #(
    parameter int SCALE = 100000
)(
    input  logic clk,
    input  logic rst,
    input  logic start,
    
    input  logic signed [31:0] x1, y1,
    input  logic signed [31:0] x2, y2,
    input  logic signed [31:0] x3, y3,
    
    output logic signed [31:0] m_out,
    output logic signed [31:0] b_out,
    output logic valid_out
);

    // ========================================
    // Параметры нормализации (из ПР№1)
    // ========================================
    localparam real X_MIN  = -10.0;
    localparam real X_MAX  =  10.0;
    localparam real Y_MIN  =  45.0;
    localparam real Y_MAX  =  55.0;
    localparam real MB_MIN = -5.0;
    localparam real MB_MAX =  5.0;

    // ========================================
    // Веса (из network_weights.txt)
    // ========================================
    
    logic signed [31:0] W1 [0:5][0:31];
    logic signed [31:0] B1 [0:31];
    logic signed [31:0] W2 [0:31][0:15];
    logic signed [31:0] B2 [0:15];
    logic signed [31:0] W3 [0:15][0:1];
    logic signed [31:0] B3 [0:1];
    
    initial begin
        // W1: 6?32
        W1[0] = '{12411, 25723, -17107, 44849, -12116, -30969, -5461, 7787, 19999, 14235, -22819, -1921, 11280, -8856, 8380, 18993, -24168, -26899, 33918, 9857, 22250, 5199, -23629, 17910, 17935, 34484, 32497, -16527, -15260, -5498, -1044, 18014};
        W1[1] = '{4761, -16346, -6542, -16194, 12998, -3928, -15669, 5691, 7362, -12110, -6290, -5424, -14010, -5894, -14576, 18508, -20972, 2909, -7274, 22899, 16442, -10487, 8922, -7364, 4233, 10186, -5290, -7318, -1434, 4080, -9157, 7313};
        W1[2] = '{37559, -29529, -15395, 165, -21580, 48774, 11, -2387, 18007, -10286, 14366, 9403, -5167, 15124, 9778, -17146, -50, -4937, -4168, 11374, -28331, 19230, 36436, -34591, 6462, -30073, 19764, -24934, -26406, 39035, -7749, 16769};
        W1[3] = '{-2732, -6967, 13032, -18536, 3596, -21020, 4395, -1333, 12126, 6616, -10782, 22856, 592, -18079, 810, 11139, -17615, 480, -5942, 5908, -7686, -21113, -4705, -17324, -6476, -18092, -2677, -15272, -3050, -8546, 14718, -9788};
        W1[4] = '{-41675, -28943, 4544, -8630, -6071, 19302, 4423, 9973, 5196, -13192, 15817, -3904, 12966, -10155, -28314, 20059, 35319, 35573, -2930, -20300, 23020, -21929, -24621, -15257, -21452, -19911, -10865, -20408, 55475, -14875, -32113, 4071};
        W1[5] = '{-4059, -8122, 23219, 10788, 11897, -301, -22410, 14403, 12030, 3020, -4354, -13544, -14983, 2748, -11316, 19108, -9702, -3837, 11064, -4376, -21450, -17636, -10923, 1709, -18804, -15118, 4069, 1743, 5607, 2307, -10038, -1842};
        
        B1 = '{-6819, 22675, 21497, 1453, -8828, -5964, 2815, -18714, -714, 23064, 14642, 9943, -2389, 3148, 19374, -11891, -7857, -4345, -15132, 22486, -11665, -16021, -6863, -26122, 3313, 3513, -26213, 22660, 11327, -18018, -8997, -9276};
        
        W2[0]  = '{-17637, 12654, -32078, -10062, 11924, -19770, -27842, -24859, -23032, 7867, -14478, -497, -11575, 6542, -381, 12731};
        W2[1]  = '{10338, 17832, 15180, -8997, 5804, 9618, -12031, -2175, 16321, 13228, -9897, 17154, 7325, -31079, -18045, -5650};
        W2[2]  = '{12350, -4115, -3801, -3440, 11455, 8737, -19787, -7510, 1301, 10137, 4475, -11618, 6043, 7270, 14680, 12128};
        W2[3]  = '{-7261, -17656, 14911, -25337, 25178, 3935, -944, -2923, -7061, -1268, 12589, -6139, 13000, -15158, -1633, 18897};
        W2[4]  = '{886, -14591, -8064, 12535, -7376, -19546, -717, -19347, 234, 17066, -11963, 17389, -9091, -13226, 20016, 7865};
        W2[5]  = '{8341, -16253, -42521, 17197, -22685, -17852, 1419, -3809, 4957, 2880, 15559, 13040, -6683, 26580, 14092, 5458};
        W2[6]  = '{-9451, 13719, 1614, 15451, -16431, -7968, 15314, 8847, -9687, -1315, 103, -10257, -9715, -1436, 12071, -916};
        W2[7]  = '{2949, -6433, 4476, -15489, -18823, 20413, -9474, -9920, -9108, -10135, 16238, 13684, -14439, 20227, -5891, 1931};
        W2[8]  = '{-342, -15119, 14675, -11504, 13259, 20342, 20054, -13990, -1210, 8468, -6532, 8013, 10141, 12961, 14194, -17081};
        W2[9]  = '{-8502, 2387, 24352, -24426, -437, 4785, 3676, -10236, 17558, 105, 8318, 4529, 4228, 17954, -16040, 15383};
        W2[10] = '{-9144, -16293, -21422, 14772, -23162, 4804, -17659, 14250, -383, 12263, 8963, 3154, -11506, 9968, 4314, 10555};
        W2[11] = '{11710, -5482, -10260, -18669, -687, 14708, 14029, 5876, 2784, -14952, -19510, -4478, -6678, 18374, -3907, -924};
        W2[12] = '{-3, -6993, -5877, 14121, 13591, -2618, 14188, -9420, -11118, -11735, -3255, -19283, 18716, -2934, 892, 20905};
        W2[13] = '{-9234, -3226, -11545, 13437, -306, -1943, -18216, -19294, -10808, -19745, -9200, 26219, -9787, -6617, -11055, 13225};
        W2[14] = '{-4178, 7666, 4191, -18803, 12155, -6850, 4737, 11156, 10019, 10691, 5636, 20099, -21920, 8589, -17277, 9534};
        W2[15] = '{-19391, -17723, -7094, 3426, -16305, 79, 12288, -17540, 13835, 7768, -15344, 1370, 14062, 4792, 20188, -6769};
        W2[16] = '{11899, -5244, 1491, 22485, -29930, 10245, 15759, 1962, -11819, -12340, 2710, -31602, -19742, 17974, 8723, -23103};
        W2[17] = '{-12665, 5552, 22917, 19376, -4035, -18307, 1626, 29693, 19147, -12023, -10950, 21663, 9573, -3040, 19312, 19690};
        W2[18] = '{-18868, 1338, 25176, 1174, 16170, 2510, 13353, 12097, 6075, -18444, -9286, 10300, 2995, 11613, 1358, 2889};
        W2[19] = '{8571, -7611, -5370, 1910, -10173, 8275, -2963, -5897, 16849, -18208, 9081, 4030, -3658, -13575, -5535, -10046};
        W2[20] = '{4294, 16432, 21049, 8645, 11358, 17889, 12371, 1405, -1471, -10787, -20010, -36027, -66, -13542, 6140, 7274};
        W2[21] = '{-18701, -7808, -7106, -7827, 5690, -5992, -2607, 11856, -14018, 4075, -18957, 3702, 15483, 16413, 11363, -12452};
        W2[22] = '{-16885, -8549, -37379, -14918, 13229, 3328, -5395, 21629, 9545, -17197, -11403, 28338, 15545, 19472, -11159, 1590};
        W2[23] = '{-17718, -15174, 9696, -20717, 29758, 10159, -4342, 208, -10759, 10098, 13347, -11657, -987, -23748, -20497, -22387};
        W2[24] = '{-1702, -7073, 11336, 11308, 14854, -22041, -15627, -13659, 8540, -5396, 2606, 21702, 10303, -3802, -18618, 2871};
        W2[25] = '{6876, -18957, 7191, -22073, 16916, 18458, 1896, 9134, 5782, -7618, -17404, -3105, -15201, -29405, -12387, 7267};
        W2[26] = '{1632, 6990, 17636, 12487, -13985, -5882, -14919, 29137, -23467, 15996, -14089, -2555, 17926, -13265, -8578, -7231};
        W2[27] = '{-7177, 18282, 10099, -10553, -15068, 10296, -3698, -1188, 26349, 9028, -13447, 9792, 2126, -4625, 11503, -12083};
        W2[28] = '{14444, -681, -36180, -14774, 10867, -4463, 7132, -37824, 334, 7447, 5981, -35550, -7766, -3806, 14224, 3175};
        W2[29] = '{-19180, 17891, -11090, 22342, -20389, -6249, -320, 22365, 8523, -9444, 18815, 20507, -10284, 17158, 745, -802};
        W2[30] = '{10072, 15937, 6363, -21111, 10910, -106, -9437, -7768, -2915, 14997, 18038, -9433, 14049, 6882, -9657, -15340};
        W2[31] = '{5430, -3865, 9814, -1478, 15370, -5703, 19263, 14435, -10051, -14239, 13838, 12773, -16223, -7679, 6888, 2139};
        
        B2 = '{26616, -21368, 20809, -2639, 3182, -26385, -12019, 3565, 73154, 9128, -33946, 17736, -9883, 20334, -6994, 42980};
        
        W3[0]  = '{-29284, 22266};
        W3[1]  = '{-10066, 31400};
        W3[2]  = '{-85189, -4824};
        W3[3]  = '{-54797, 6855};
        W3[4]  = '{67778, 3660};
        W3[5]  = '{33851, 3800};
        W3[6]  = '{-27119, 3393};
        W3[7]  = '{-53534, -36600};
        W3[8]  = '{-56222, 60012};
        W3[9]  = '{1073, -5173};
        W3[10] = '{15458, -32361};
        W3[11] = '{-76585, 14205};
        W3[12] = '{22234, 25999};
        W3[13] = '{63604, 883};
        W3[14] = '{-25959, 32549};
        W3[15] = '{1703, 44875};
        
        B3 = '{66792, 6553};
    end
    
    // ========================================
    // Pipeline регистры
    // ========================================
    
    logic signed [31:0] input_norm [0:5];
    logic signed [31:0] layer1_z [0:31];
    logic signed [31:0] layer1_a [0:31];
    logic signed [31:0] layer2_z [0:15];
    logic signed [31:0] layer2_a [0:15];
    logic signed [31:0] layer3_z [0:1];
    
    typedef enum logic [3:0] {
        IDLE,
        NORMALIZE,
        COMPUTE_L1,
        RELU_L1,
        COMPUTE_L2,
        RELU_L2,
        COMPUTE_L3,
        DENORM,
        DONE
    } state_t;
    
    state_t state, next_state;
    
    // ========================================
    // FSM
    // ========================================
    
    always_ff @(posedge clk or posedge rst) begin
        if (rst) state <= IDLE;
        else state <= next_state;
    end
    
    always_comb begin
        next_state = state;
        case (state)
            IDLE:       if (start) next_state = NORMALIZE;
            NORMALIZE:  next_state = COMPUTE_L1;
            COMPUTE_L1: next_state = RELU_L1;
            RELU_L1:    next_state = COMPUTE_L2;
            COMPUTE_L2: next_state = RELU_L2;
            RELU_L2:    next_state = COMPUTE_L3;
            COMPUTE_L3: next_state = DENORM;
            DENORM:     next_state = DONE;
            DONE:       next_state = IDLE;
            default:    next_state = IDLE;
        endcase
    end
    
    // ========================================
    // Вычисления
    // ========================================
    
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            valid_out <= 0;
            m_out <= 0;
            b_out <= 0;
        end else begin
            valid_out <= 0;
            
            case (state)
                NORMALIZE: begin
                    input_norm[0] <= norm_input(x1, X_MIN, X_MAX);
                    input_norm[1] <= norm_input(y1, Y_MIN, Y_MAX);
                    input_norm[2] <= norm_input(x2, X_MIN, X_MAX);
                    input_norm[3] <= norm_input(y2, Y_MIN, Y_MAX);
                    input_norm[4] <= norm_input(x3, X_MIN, X_MAX);
                    input_norm[5] <= norm_input(y3, Y_MIN, Y_MAX);
                end
                
                COMPUTE_L1: begin
                    for (int i = 0; i < 32; i++) begin
                        layer1_z[i] <= compute_l1(input_norm, i);
                    end
                end
                
                RELU_L1: begin
                    for (int i = 0; i < 32; i++) begin
                        layer1_a[i] <= (layer1_z[i] < 0) ? 32'sd0 : layer1_z[i];
                    end
                end
                
                COMPUTE_L2: begin
                    for (int i = 0; i < 16; i++) begin
                        layer2_z[i] <= compute_l2(layer1_a, i);
                    end
                end
                
                RELU_L2: begin
                    for (int i = 0; i < 16; i++) begin
                        layer2_a[i] <= (layer2_z[i] < 0) ? 32'sd0 : layer2_z[i];
                    end
                end
                
                COMPUTE_L3: begin
                    for (int i = 0; i < 2; i++) begin
                        layer3_z[i] <= compute_l3(layer2_a, i);
                    end
                end
                
                DENORM: begin
                    m_out <= denorm_output(layer3_z[0], MB_MIN, MB_MAX);
                    b_out <= denorm_output(layer3_z[1], MB_MIN, MB_MAX);
                end
                
                DONE: begin
                    valid_out <= 1;
                end
            endcase
        end
    end
    
    // ========================================
    // Функции нормализации (ТОЧНО КАК В C++)
    // ========================================
    
    function automatic logic signed [31:0] norm_input(
        logic signed [31:0] val,
        real min_v,
        real max_v
    );
        real val_f = real'(val) / real'(SCALE);
        real norm = 2.0 * (val_f - min_v) / (max_v - min_v) - 1.0;
        return longint'(norm * real'(SCALE));
    endfunction
    
    function automatic logic signed [31:0] denorm_output(
        logic signed [31:0] val,
        real min_v,
        real max_v
    );
        real val_f = real'(val) / real'(SCALE);
        real denorm = (val_f + 1.0) / 2.0 * (max_v - min_v) + min_v;
        return longint'(denorm * real'(SCALE));
    endfunction
    
    // ========================================
    // Вычисление Layer 1
    // ========================================
    
    function automatic logic signed [31:0] compute_l1(
        logic signed [31:0] inputs [0:5],
        int idx
    );
        // Вычисляем сумму произведений
        longint acc;
        longint prod0, prod1, prod2, prod3, prod4, prod5;
        
        // a * b / SCALE для каждого произведения
        prod0 = (longint'(inputs[0]) * longint'(W1[0][idx])) / SCALE;
        prod1 = (longint'(inputs[1]) * longint'(W1[1][idx])) / SCALE;
        prod2 = (longint'(inputs[2]) * longint'(W1[2][idx])) / SCALE;
        prod3 = (longint'(inputs[3]) * longint'(W1[3][idx])) / SCALE;
        prod4 = (longint'(inputs[4]) * longint'(W1[4][idx])) / SCALE;
        prod5 = (longint'(inputs[5]) * longint'(W1[5][idx])) / SCALE;
        
        // Суммируем все произведения + bias
        acc = prod0 + prod1 + prod2 + prod3 + prod4 + prod5 + longint'(B1[idx]);
        
        return acc[31:0];
    endfunction
    
    // ========================================
    // Вычисление Layer 2
    // ========================================
    
    function automatic logic signed [31:0] compute_l2(
        logic signed [31:0] inputs [0:31],
        int idx
    );
        longint acc = 0;
        longint prod;
        
        for (int i = 0; i < 32; i++) begin
            prod = (longint'(inputs[i]) * longint'(W2[i][idx])) / SCALE;
            acc = acc + prod;
        end
        
        acc = acc + longint'(B2[idx]);
        return acc[31:0];
    endfunction
    
    // ========================================
    // Вычисление Layer 3
    // ========================================
    
    function automatic logic signed [31:0] compute_l3(
        logic signed [31:0] inputs [0:15],
        int idx
    );
        longint acc = 0;
        longint prod;
        
        for (int i = 0; i < 16; i++) begin
            prod = (longint'(inputs[i]) * longint'(W3[i][idx])) / SCALE;
            acc = acc + prod;
        end
        
        acc = acc + longint'(B3[idx]);
        return acc[31:0];
    endfunction

endmodule
```

### Тестовый модуль

```systemverilog
/*
 * Testbench для нейронной сети
 * Тестирует inference на различных наборах точек
 */

`timescale 1ns / 1ps

module tb_neural_inference_sv;

    localparam int SCALE = 100000;
    localparam int CLK_PERIOD = 10;
    
    // Сигналы DUT
    logic clk;
    logic rst;
    logic start;
    logic signed [31:0] x1, y1, x2, y2, x3, y3;
    logic signed [31:0] m_out, b_out;
    logic valid_out;
    
    // ========================================
    // Инстанцирование DUT
    // ========================================
    neural_inference_sv #(
        .SCALE(SCALE)
    ) dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .x1(x1), .y1(y1),
        .x2(x2), .y2(y2),
        .x3(x3), .y3(y3),
        .m_out(m_out),
        .b_out(b_out),
        .valid_out(valid_out)
    );
    
    // ========================================
    // Генератор тактов
    // ========================================
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    // ========================================
    // Функции преобразования
    // ========================================
    function automatic longint to_fixed(real value);
        return longint'(value * SCALE);
    endfunction
    
    function automatic real from_fixed(longint fixed_val);
        return real'(fixed_val) / SCALE;
    endfunction
    
    // ========================================
    // Task для запуска inference
    // ========================================
    task automatic run_inference(
        real x1_r, real y1_r,
        real x2_r, real y2_r,
        real x3_r, real y3_r,
        real expected_m,
        real expected_b
    );
        real m_result, b_result, m_err, b_err;
        
        @(posedge clk);
        
        // Загружаем точки
        x1 = to_fixed(x1_r);
        y1 = to_fixed(y1_r);
        x2 = to_fixed(x2_r);
        y2 = to_fixed(y2_r);
        x3 = to_fixed(x3_r);
        y3 = to_fixed(y3_r);
        
        // Запускаем
        start = 1;
        @(posedge clk);
        start = 0;
        
        // Ждём результата
        wait(valid_out);
        @(posedge clk);
        
        // Декодируем результат
        m_result = from_fixed(m_out);
        b_result = from_fixed(b_out);
        
        // Вычисляем ошибки
        m_err = (m_result - expected_m);
        b_err = (b_result - expected_b);
        if (m_err < 0) m_err = -m_err;
        if (b_err < 0) b_err = -b_err;
        
        // Вывод
        $display("Точки: (%.2f,%.2f), (%.2f,%.2f), (%.2f,%.2f)", 
                 x1_r, y1_r, x2_r, y2_r, x3_r, y3_r);
        $display("  Ожидалось: m = %8.4f, b = %8.4f", expected_m, expected_b);
        $display("  Получено:  m = %8.4f, b = %8.4f", m_result, b_result);
        $display("  Ошибка:    ?m = %7.4f, ?b = %7.4f", m_err, b_err);
        
        if (m_err < 0.2 && b_err < 0.2) begin
            $display("  ? PASSED");
        end else begin
            $display("  ? FAILED (большая ошибка)");
        end
        $display("");
        
    endtask
    
    // ========================================
    // Основной тест
    // ========================================
    initial begin
        $display("========================================");
        $display("  Testbench: Neural Network Inference");
        $display("  Архитектура: 6 ? 32 ? 16 ? 2");
        $display("  Веса загружены из ПР№1");
        $display("========================================\n");
        
        // Инициализация
        rst = 1;
        start = 0;
        x1 = 0; y1 = 0;
        x2 = 0; y2 = 0;
        x3 = 0; y3 = 0;
        
        repeat(5) @(posedge clk);
        rst = 0;
        repeat(2) @(posedge clk);
        
        // ========================================
        // ТЕСТ 1: y = 2x + 1
        // ========================================
        $display("[TEST 1] Прямая y = 2x + 1");
        run_inference(
            1.0, 3.0,
            2.0, 5.0,
            3.0, 7.0,
            2.0, 1.0
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // ТЕСТ 2: y = -1.5x + 2
        // ========================================
        $display("[TEST 2] Прямая y = -1.5x + 2");
        run_inference(
            0.0, 2.0,
            2.0, -1.0,
            4.0, -4.0,
            -1.5, 2.0
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // ТЕСТ 3: y = 0.5x + 0.5
        // ========================================
        $display("[TEST 3] Прямая y = 0.5x + 0.5");
        run_inference(
            -1.0, 0.0,
            1.0, 1.0,
            3.0, 2.0,
            0.5, 0.5
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // ТЕСТ 4: y = -3x - 1
        // ========================================
        $display("[TEST 4] Прямая y = -3x - 1");
        run_inference(
            0.0, -1.0,
            1.0, -4.0,
            -1.0, 2.0,
            -3.0, -1.0
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // ТЕСТ 5: Горизонтальная y = 3
        // ========================================
        $display("[TEST 5] Горизонтальная y = 3");
        run_inference(
            -2.0, 3.0,
            0.0, 3.0,
            5.0, 3.0,
            0.0, 3.0
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // ТЕСТ 6: Вертикальная (невозможно)
        // ========================================
        $display("[TEST 6] Почти вертикальная линия");
        run_inference(
            1.0, -5.0,
            1.01, 0.0,
            1.02, 5.0,
            500.0, -500.0  // Ожидаем большие числа
        );
        
        repeat(10) @(posedge clk);
        
        // ========================================
        // Завершение
        // ========================================
        $display("========================================");
        $display("  Все тесты завершены!");
        $display("========================================");
        
        repeat(20) @(posedge clk);
        $finish;
    end
    
    // ========================================
    // Таймаут
    // ========================================
    initial begin
        #(CLK_PERIOD * 10000);
        $display("\nОШИБКА: Таймаут симуляции!");
        $finish;
    end
    
    // ========================================
    // VCD dump (опционально)
    // ========================================
    initial begin
        $dumpfile("tb_neural_inference.vcd");
        $dumpvars(0, tb_neural_inference);
    end

endmodule
```

## Этап 2. Переход к Verilog 2001
Ниже представлен код модулей на языке Verilog, переведённый из SystemVerilog.
### Модуль нейропроцессора

```verilog
/*
 * Нейронная сеть для inference (Verilog 2001)
 * Архитектура: 6 ? 32 ? 16 ? 2
 * Веса из network_weights.txt (scale=100000)
 */

module neural_inference #(
    parameter SCALE = 100000
)(
    input  wire clk,
    input  wire rst,
    input  wire start,
    
    // Входные точки: 3 точки ? (x, y)
    input  wire signed [31:0] x1,
    input  wire signed [31:0] y1,
    input  wire signed [31:0] x2,
    input  wire signed [31:0] y2,
    input  wire signed [31:0] x3,
    input  wire signed [31:0] y3,
    
    // Выходные коэффициенты
    output reg  signed [31:0] m_out,
    output reg  signed [31:0] b_out,
    output reg  valid_out
);

    // ========================================
    // Константы нормализации (фиксированные значения)
    // X_MIN=-10.0 ? -10*100000 = -1000000
    // X_MAX= 10.0 ?  10*100000 =  1000000
    // Y_MIN= 45.0 ?  45*100000 =  4500000
    // Y_MAX= 55.0 ?  55*100000 =  5500000
    // MB_MIN=-5.0 ?  -5*100000 = -500000
    // MB_MAX= 5.0 ?   5*100000 =  500000
    // ========================================
    
    // ========================================
    // Состояния FSM
    // ========================================
    parameter [3:0] IDLE       = 4'd0;
    parameter [3:0] NORMALIZE  = 4'd1;
    parameter [3:0] COMPUTE_L1 = 4'd2;
    parameter [3:0] RELU_L1    = 4'd3;
    parameter [3:0] COMPUTE_L2 = 4'd4;
    parameter [3:0] RELU_L2    = 4'd5;
    parameter [3:0] COMPUTE_L3 = 4'd6;
    parameter [3:0] DENORM     = 4'd7;
    parameter [3:0] DONE       = 4'd8;
    
    reg [3:0] state, next_state;
    
    // ========================================
    // Хранилище весов W1[6][32]
    // ========================================
    reg signed [31:0] W1_0  [0:31];
    reg signed [31:0] W1_1  [0:31];
    reg signed [31:0] W1_2  [0:31];
    reg signed [31:0] W1_3  [0:31];
    reg signed [31:0] W1_4  [0:31];
    reg signed [31:0] W1_5  [0:31];
    reg signed [31:0] B1    [0:31];
    
    // W2[32][16]
    reg signed [31:0] W2_0  [0:15];
    reg signed [31:0] W2_1  [0:15];
    reg signed [31:0] W2_2  [0:15];
    reg signed [31:0] W2_3  [0:15];
    reg signed [31:0] W2_4  [0:15];
    reg signed [31:0] W2_5  [0:15];
    reg signed [31:0] W2_6  [0:15];
    reg signed [31:0] W2_7  [0:15];
    reg signed [31:0] W2_8  [0:15];
    reg signed [31:0] W2_9  [0:15];
    reg signed [31:0] W2_10 [0:15];
    reg signed [31:0] W2_11 [0:15];
    reg signed [31:0] W2_12 [0:15];
    reg signed [31:0] W2_13 [0:15];
    reg signed [31:0] W2_14 [0:15];
    reg signed [31:0] W2_15 [0:15];
    reg signed [31:0] W2_16 [0:15];
    reg signed [31:0] W2_17 [0:15];
    reg signed [31:0] W2_18 [0:15];
    reg signed [31:0] W2_19 [0:15];
    reg signed [31:0] W2_20 [0:15];
    reg signed [31:0] W2_21 [0:15];
    reg signed [31:0] W2_22 [0:15];
    reg signed [31:0] W2_23 [0:15];
    reg signed [31:0] W2_24 [0:15];
    reg signed [31:0] W2_25 [0:15];
    reg signed [31:0] W2_26 [0:15];
    reg signed [31:0] W2_27 [0:15];
    reg signed [31:0] W2_28 [0:15];
    reg signed [31:0] W2_29 [0:15];
    reg signed [31:0] W2_30 [0:15];
    reg signed [31:0] W2_31 [0:15];
    reg signed [31:0] B2    [0:15];
    
    // W3[16][2]
    reg signed [31:0] W3_0  [0:1];
    reg signed [31:0] W3_1  [0:1];
    reg signed [31:0] W3_2  [0:1];
    reg signed [31:0] W3_3  [0:1];
    reg signed [31:0] W3_4  [0:1];
    reg signed [31:0] W3_5  [0:1];
    reg signed [31:0] W3_6  [0:1];
    reg signed [31:0] W3_7  [0:1];
    reg signed [31:0] W3_8  [0:1];
    reg signed [31:0] W3_9  [0:1];
    reg signed [31:0] W3_10 [0:1];
    reg signed [31:0] W3_11 [0:1];
    reg signed [31:0] W3_12 [0:1];
    reg signed [31:0] W3_13 [0:1];
    reg signed [31:0] W3_14 [0:1];
    reg signed [31:0] W3_15 [0:1];
    reg signed [31:0] B3    [0:1];
    
    // ========================================
    // Инициализация весов
    // ========================================
    initial begin
        // W1 row 0
        W1_0[0]=12411;   W1_0[1]=25723;   W1_0[2]=-17107;  W1_0[3]=44849;   W1_0[4]=-12116;  W1_0[5]=-30969;  W1_0[6]=-5461;   W1_0[7]=7787;
        W1_0[8]=19999;   W1_0[9]=14235;   W1_0[10]=-22819; W1_0[11]=-1921;  W1_0[12]=11280;  W1_0[13]=-8856;  W1_0[14]=8380;   W1_0[15]=18993;
        W1_0[16]=-24168; W1_0[17]=-26899; W1_0[18]=33918;  W1_0[19]=9857;   W1_0[20]=22250;  W1_0[21]=5199;   W1_0[22]=-23629; W1_0[23]=17910;
        W1_0[24]=17935;  W1_0[25]=34484;  W1_0[26]=32497;  W1_0[27]=-16527; W1_0[28]=-15260; W1_0[29]=-5498;  W1_0[30]=-1044;  W1_0[31]=18014;
        
        // W1 row 1
        W1_1[0]=4761;    W1_1[1]=-16346;  W1_1[2]=-6542;   W1_1[3]=-16194;  W1_1[4]=12998;   W1_1[5]=-3928;   W1_1[6]=-15669;  W1_1[7]=5691;
        W1_1[8]=7362;    W1_1[9]=-12110;  W1_1[10]=-6290;  W1_1[11]=-5424;  W1_1[12]=-14010; W1_1[13]=-5894;  W1_1[14]=-14576; W1_1[15]=18508;
        W1_1[16]=-20972; W1_1[17]=2909;   W1_1[18]=-7274;  W1_1[19]=22899;  W1_1[20]=16442;  W1_1[21]=-10487; W1_1[22]=8922;   W1_1[23]=-7364;
        W1_1[24]=4233;   W1_1[25]=10186;  W1_1[26]=-5290;  W1_1[27]=-7318;  W1_1[28]=-1434;  W1_1[29]=4080;   W1_1[30]=-9157;  W1_1[31]=7313;
        
        // W1 row 2
        W1_2[0]=37559;   W1_2[1]=-29529;  W1_2[2]=-15395;  W1_2[3]=165;     W1_2[4]=-21580;  W1_2[5]=48774;   W1_2[6]=11;      W1_2[7]=-2387;
        W1_2[8]=18007;   W1_2[9]=-10286;  W1_2[10]=14366;  W1_2[11]=9403;   W1_2[12]=-5167;  W1_2[13]=15124;  W1_2[14]=9778;   W1_2[15]=-17146;
        W1_2[16]=-50;    W1_2[17]=-4937;  W1_2[18]=-4168;  W1_2[19]=11374;  W1_2[20]=-28331; W1_2[21]=19230;  W1_2[22]=36436;  W1_2[23]=-34591;
        W1_2[24]=6462;   W1_2[25]=-30073; W1_2[26]=19764;  W1_2[27]=-24934; W1_2[28]=-26406; W1_2[29]=39035;  W1_2[30]=-7749;  W1_2[31]=16769;
        
        // W1 row 3
        W1_3[0]=-2732;   W1_3[1]=-6967;   W1_3[2]=13032;   W1_3[3]=-18536;  W1_3[4]=3596;    W1_3[5]=-21020;  W1_3[6]=4395;    W1_3[7]=-1333;
        W1_3[8]=12126;   W1_3[9]=6616;    W1_3[10]=-10782; W1_3[11]=22856;  W1_3[12]=592;    W1_3[13]=-18079; W1_3[14]=810;    W1_3[15]=11139;
        W1_3[16]=-17615; W1_3[17]=480;    W1_3[18]=-5942;  W1_3[19]=5908;   W1_3[20]=-7686;  W1_3[21]=-21113; W1_3[22]=-4705;  W1_3[23]=-17324;
        W1_3[24]=-6476;  W1_3[25]=-18092; W1_3[26]=-2677;  W1_3[27]=-15272; W1_3[28]=-3050;  W1_3[29]=-8546;  W1_3[30]=14718;  W1_3[31]=-9788;
        
        // W1 row 4
        W1_4[0]=-41675;  W1_4[1]=-28943;  W1_4[2]=4544;    W1_4[3]=-8630;   W1_4[4]=-6071;   W1_4[5]=19302;   W1_4[6]=4423;    W1_4[7]=9973;
        W1_4[8]=5196;    W1_4[9]=-13192;  W1_4[10]=15817;  W1_4[11]=-3904;  W1_4[12]=12966;  W1_4[13]=-10155; W1_4[14]=-28314; W1_4[15]=20059;
        W1_4[16]=35319;  W1_4[17]=35573;  W1_4[18]=-2930;  W1_4[19]=-20300; W1_4[20]=23020;  W1_4[21]=-21929; W1_4[22]=-24621; W1_4[23]=-15257;
        W1_4[24]=-21452; W1_4[25]=-19911; W1_4[26]=-10865; W1_4[27]=-20408; W1_4[28]=55475;  W1_4[29]=-14875; W1_4[30]=-32113; W1_4[31]=4071;
        
        // W1 row 5
        W1_5[0]=-4059;   W1_5[1]=-8122;   W1_5[2]=23219;   W1_5[3]=10788;   W1_5[4]=11897;   W1_5[5]=-301;    W1_5[6]=-22410;  W1_5[7]=14403;
        W1_5[8]=12030;   W1_5[9]=3020;    W1_5[10]=-4354;  W1_5[11]=-13544; W1_5[12]=-14983; W1_5[13]=2748;   W1_5[14]=-11316; W1_5[15]=19108;
        W1_5[16]=-9702;  W1_5[17]=-3837;  W1_5[18]=11064;  W1_5[19]=-4376;  W1_5[20]=-21450; W1_5[21]=-17636; W1_5[22]=-10923; W1_5[23]=1709;
        W1_5[24]=-18804; W1_5[25]=-15118; W1_5[26]=4069;   W1_5[27]=1743;   W1_5[28]=5607;   W1_5[29]=2307;   W1_5[30]=-10038; W1_5[31]=-1842;
        
        // B1
        B1[0]=-6819;  B1[1]=22675;  B1[2]=21497;  B1[3]=1453;   B1[4]=-8828;  B1[5]=-5964;  B1[6]=2815;   B1[7]=-18714;
        B1[8]=-714;   B1[9]=23064;  B1[10]=14642; B1[11]=9943;  B1[12]=-2389; B1[13]=3148;  B1[14]=19374; B1[15]=-11891;
        B1[16]=-7857; B1[17]=-4345; B1[18]=-15132;B1[19]=22486; B1[20]=-11665;B1[21]=-16021;B1[22]=-6863; B1[23]=-26122;
        B1[24]=3313;  B1[25]=3513;  B1[26]=-26213;B1[27]=22660; B1[28]=11327; B1[29]=-18018;B1[30]=-8997; B1[31]=-9276;
        
        // W2 (32 строк ? 16 столбцов)
        W2_0[0]=-17637;  W2_0[1]=12654;   W2_0[2]=-32078;  W2_0[3]=-10062;  W2_0[4]=11924;   W2_0[5]=-19770;  W2_0[6]=-27842;  W2_0[7]=-24859;
        W2_0[8]=-23032;  W2_0[9]=7867;    W2_0[10]=-14478; W2_0[11]=-497;   W2_0[12]=-11575; W2_0[13]=6542;   W2_0[14]=-381;   W2_0[15]=12731;
        
        W2_1[0]=10338;   W2_1[1]=17832;   W2_1[2]=15180;   W2_1[3]=-8997;   W2_1[4]=5804;    W2_1[5]=9618;    W2_1[6]=-12031;  W2_1[7]=-2175;
        W2_1[8]=16321;   W2_1[9]=13228;   W2_1[10]=-9897;  W2_1[11]=17154;  W2_1[12]=7325;   W2_1[13]=-31079; W2_1[14]=-18045; W2_1[15]=-5650;
        
        W2_2[0]=12350;   W2_2[1]=-4115;   W2_2[2]=-3801;   W2_2[3]=-3440;   W2_2[4]=11455;   W2_2[5]=8737;    W2_2[6]=-19787;  W2_2[7]=-7510;
        W2_2[8]=1301;    W2_2[9]=10137;   W2_2[10]=4475;   W2_2[11]=-11618; W2_2[12]=6043;   W2_2[13]=7270;   W2_2[14]=14680;  W2_2[15]=12128;
        
        W2_3[0]=-7261;   W2_3[1]=-17656;  W2_3[2]=14911;   W2_3[3]=-25337;  W2_3[4]=25178;   W2_3[5]=3935;    W2_3[6]=-944;    W2_3[7]=-2923;
        W2_3[8]=-7061;   W2_3[9]=-1268;   W2_3[10]=12589;  W2_3[11]=-6139;  W2_3[12]=13000;  W2_3[13]=-15158; W2_3[14]=-1633;  W2_3[15]=18897;
        
        W2_4[0]=886;     W2_4[1]=-14591;  W2_4[2]=-8064;   W2_4[3]=12535;   W2_4[4]=-7376;   W2_4[5]=-19546;  W2_4[6]=-717;    W2_4[7]=-19347;
        W2_4[8]=234;     W2_4[9]=17066;   W2_4[10]=-11963; W2_4[11]=17389;  W2_4[12]=-9091;  W2_4[13]=-13226; W2_4[14]=20016;  W2_4[15]=7865;
        
        W2_5[0]=8341;    W2_5[1]=-16253;  W2_5[2]=-42521;  W2_5[3]=17197;   W2_5[4]=-22685;  W2_5[5]=-17852;  W2_5[6]=1419;    W2_5[7]=-3809;
        W2_5[8]=4957;    W2_5[9]=2880;    W2_5[10]=15559;  W2_5[11]=13040;  W2_5[12]=-6683;  W2_5[13]=26580;  W2_5[14]=14092;  W2_5[15]=5458;
        
        W2_6[0]=-9451;   W2_6[1]=13719;   W2_6[2]=1614;    W2_6[3]=15451;   W2_6[4]=-16431;  W2_6[5]=-7968;   W2_6[6]=15314;   W2_6[7]=8847;
        W2_6[8]=-9687;   W2_6[9]=-1315;   W2_6[10]=103;    W2_6[11]=-10257; W2_6[12]=-9715;  W2_6[13]=-1436;  W2_6[14]=12071;  W2_6[15]=-916;
        
        W2_7[0]=2949;    W2_7[1]=-6433;   W2_7[2]=4476;    W2_7[3]=-15489;  W2_7[4]=-18823;  W2_7[5]=20413;   W2_7[6]=-9474;   W2_7[7]=-9920;
        W2_7[8]=-9108;   W2_7[9]=-10135;  W2_7[10]=16238;  W2_7[11]=13684;  W2_7[12]=-14439; W2_7[13]=20227;  W2_7[14]=-5891;  W2_7[15]=1931;
        
        W2_8[0]=-342;    W2_8[1]=-15119;  W2_8[2]=14675;   W2_8[3]=-11504;  W2_8[4]=13259;   W2_8[5]=20342;   W2_8[6]=20054;   W2_8[7]=-13990;
        W2_8[8]=-1210;   W2_8[9]=8468;    W2_8[10]=-6532;  W2_8[11]=8013;   W2_8[12]=10141;  W2_8[13]=12961;  W2_8[14]=14194;  W2_8[15]=-17081;
        
        W2_9[0]=-8502;   W2_9[1]=2387;    W2_9[2]=24352;   W2_9[3]=-24426;  W2_9[4]=-437;    W2_9[5]=4785;    W2_9[6]=3676;    W2_9[7]=-10236;
        W2_9[8]=17558;   W2_9[9]=105;     W2_9[10]=8318;   W2_9[11]=4529;   W2_9[12]=4228;   W2_9[13]=17954;  W2_9[14]=-16040; W2_9[15]=15383;
        
        W2_10[0]=-9144;  W2_10[1]=-16293; W2_10[2]=-21422; W2_10[3]=14772;  W2_10[4]=-23162; W2_10[5]=4804;   W2_10[6]=-17659; W2_10[7]=14250;
        W2_10[8]=-383;   W2_10[9]=12263;  W2_10[10]=8963;  W2_10[11]=3154;  W2_10[12]=-11506;W2_10[13]=9968;  W2_10[14]=4314;  W2_10[15]=10555;
        
        W2_11[0]=11710;  W2_11[1]=-5482;  W2_11[2]=-10260; W2_11[3]=-18669; W2_11[4]=-687;   W2_11[5]=14708;  W2_11[6]=14029;  W2_11[7]=5876;
        W2_11[8]=2784;   W2_11[9]=-14952; W2_11[10]=-19510;W2_11[11]=-4478; W2_11[12]=-6678; W2_11[13]=18374; W2_11[14]=-3907; W2_11[15]=-924;
        
        W2_12[0]=-3;     W2_12[1]=-6993;  W2_12[2]=-5877;  W2_12[3]=14121;  W2_12[4]=13591;  W2_12[5]=-2618;  W2_12[6]=14188;  W2_12[7]=-9420;
        W2_12[8]=-11118; W2_12[9]=-11735; W2_12[10]=-3255; W2_12[11]=-19283;W2_12[12]=18716; W2_12[13]=-2934; W2_12[14]=892;   W2_12[15]=20905;
        
        W2_13[0]=-9234;  W2_13[1]=-3226;  W2_13[2]=-11545; W2_13[3]=13437;  W2_13[4]=-306;   W2_13[5]=-1943;  W2_13[6]=-18216; W2_13[7]=-19294;
        W2_13[8]=-10808; W2_13[9]=-19745; W2_13[10]=-9200; W2_13[11]=26219; W2_13[12]=-9787; W2_13[13]=-6617; W2_13[14]=-11055;W2_13[15]=13225;
        
        W2_14[0]=-4178;  W2_14[1]=7666;   W2_14[2]=4191;   W2_14[3]=-18803; W2_14[4]=12155;  W2_14[5]=-6850;  W2_14[6]=4737;   W2_14[7]=11156;
        W2_14[8]=10019;  W2_14[9]=10691;  W2_14[10]=5636;  W2_14[11]=20099; W2_14[12]=-21920;W2_14[13]=8589;  W2_14[14]=-17277;W2_14[15]=9534;
        
        W2_15[0]=-19391; W2_15[1]=-17723; W2_15[2]=-7094;  W2_15[3]=3426;   W2_15[4]=-16305; W2_15[5]=79;     W2_15[6]=12288;  W2_15[7]=-17540;
        W2_15[8]=13835;  W2_15[9]=7768;   W2_15[10]=-15344;W2_15[11]=1370;  W2_15[12]=14062; W2_15[13]=4792;  W2_15[14]=20188; W2_15[15]=-6769;
        
        W2_16[0]=11899;  W2_16[1]=-5244;  W2_16[2]=1491;   W2_16[3]=22485;  W2_16[4]=-29930; W2_16[5]=10245;  W2_16[6]=15759;  W2_16[7]=1962;
        W2_16[8]=-11819; W2_16[9]=-12340; W2_16[10]=2710;  W2_16[11]=-31602;W2_16[12]=-19742;W2_16[13]=17974; W2_16[14]=8723;  W2_16[15]=-23103;
        
        W2_17[0]=-12665; W2_17[1]=5552;   W2_17[2]=22917;  W2_17[3]=19376;  W2_17[4]=-4035;  W2_17[5]=-18307; W2_17[6]=1626;   W2_17[7]=29693;
        W2_17[8]=19147;  W2_17[9]=-12023; W2_17[10]=-10950;W2_17[11]=21663; W2_17[12]=9573;  W2_17[13]=-3040; W2_17[14]=19312; W2_17[15]=19690;
        
        W2_18[0]=-18868; W2_18[1]=1338;   W2_18[2]=25176;  W2_18[3]=1174;   W2_18[4]=16170;  W2_18[5]=2510;   W2_18[6]=13353;  W2_18[7]=12097;
        W2_18[8]=6075;   W2_18[9]=-18444; W2_18[10]=-9286; W2_18[11]=10300; W2_18[12]=2995;  W2_18[13]=11613; W2_18[14]=1358;  W2_18[15]=2889;
        
        W2_19[0]=8571;   W2_19[1]=-7611;  W2_19[2]=-5370;  W2_19[3]=1910;   W2_19[4]=-10173; W2_19[5]=8275;   W2_19[6]=-2963;  W2_19[7]=-5897;
        W2_19[8]=16849;  W2_19[9]=-18208; W2_19[10]=9081;  W2_19[11]=4030;  W2_19[12]=-3658; W2_19[13]=-13575;W2_19[14]=-5535; W2_19[15]=-10046;
        
        W2_20[0]=4294;   W2_20[1]=16432;  W2_20[2]=21049;  W2_20[3]=8645;   W2_20[4]=11358;  W2_20[5]=17889;  W2_20[6]=12371;  W2_20[7]=1405;
        W2_20[8]=-1471;  W2_20[9]=-10787; W2_20[10]=-20010;W2_20[11]=-36027;W2_20[12]=-66;   W2_20[13]=-13542;W2_20[14]=6140;  W2_20[15]=7274;
        
        W2_21[0]=-18701; W2_21[1]=-7808;  W2_21[2]=-7106;  W2_21[3]=-7827;  W2_21[4]=5690;   W2_21[5]=-5992;  W2_21[6]=-2607;  W2_21[7]=11856;
        W2_21[8]=-14018; W2_21[9]=4075;   W2_21[10]=-18957;W2_21[11]=3702;  W2_21[12]=15483; W2_21[13]=16413; W2_21[14]=11363; W2_21[15]=-12452;
        
        W2_22[0]=-16885; W2_22[1]=-8549;  W2_22[2]=-37379; W2_22[3]=-14918; W2_22[4]=13229;  W2_22[5]=3328;   W2_22[6]=-5395;  W2_22[7]=21629;
        W2_22[8]=9545;   W2_22[9]=-17197; W2_22[10]=-11403;W2_22[11]=28338; W2_22[12]=15545; W2_22[13]=19472; W2_22[14]=-11159;W2_22[15]=1590;
        
        W2_23[0]=-17718; W2_23[1]=-15174; W2_23[2]=9696;   W2_23[3]=-20717; W2_23[4]=29758;  W2_23[5]=10159;  W2_23[6]=-4342;  W2_23[7]=208;
        W2_23[8]=-10759; W2_23[9]=10098;  W2_23[10]=13347; W2_23[11]=-11657;W2_23[12]=-987;  W2_23[13]=-23748;W2_23[14]=-20497;W2_23[15]=-22387;
        
        W2_24[0]=-1702;  W2_24[1]=-7073;  W2_24[2]=11336;  W2_24[3]=11308;  W2_24[4]=14854;  W2_24[5]=-22041; W2_24[6]=-15627; W2_24[7]=-13659;
        W2_24[8]=8540;   W2_24[9]=-5396;  W2_24[10]=2606;  W2_24[11]=21702; W2_24[12]=10303; W2_24[13]=-3802; W2_24[14]=-18618;W2_24[15]=2871;
        
        W2_25[0]=6876;   W2_25[1]=-18957; W2_25[2]=7191;   W2_25[3]=-22073; W2_25[4]=16916;  W2_25[5]=18458;  W2_25[6]=1896;   W2_25[7]=9134;
        W2_25[8]=5782;   W2_25[9]=-7618;  W2_25[10]=-17404;W2_25[11]=-3105; W2_25[12]=-15201;W2_25[13]=-29405;W2_25[14]=-12387;W2_25[15]=7267;
        
        W2_26[0]=1632;   W2_26[1]=6990;   W2_26[2]=17636;  W2_26[3]=12487;  W2_26[4]=-13985; W2_26[5]=-5882;  W2_26[6]=-14919; W2_26[7]=29137;
        W2_26[8]=-23467; W2_26[9]=15996;  W2_26[10]=-14089;W2_26[11]=-2555; W2_26[12]=17926; W2_26[13]=-13265;W2_26[14]=-8578; W2_26[15]=-7231;
        
        W2_27[0]=-7177;  W2_27[1]=18282;  W2_27[2]=10099;  W2_27[3]=-10553; W2_27[4]=-15068; W2_27[5]=10296;  W2_27[6]=-3698;  W2_27[7]=-1188;
        W2_27[8]=26349;  W2_27[9]=9028;   W2_27[10]=-13447;W2_27[11]=9792;  W2_27[12]=2126;  W2_27[13]=-4625; W2_27[14]=11503; W2_27[15]=-12083;
        
        W2_28[0]=14444;  W2_28[1]=-681;   W2_28[2]=-36180; W2_28[3]=-14774; W2_28[4]=10867;  W2_28[5]=-4463;  W2_28[6]=7132;   W2_28[7]=-37824;
        W2_28[8]=334;    W2_28[9]=7447;   W2_28[10]=5981;  W2_28[11]=-35550;W2_28[12]=-7766; W2_28[13]=-3806; W2_28[14]=14224; W2_28[15]=3175;
        
        W2_29[0]=-19180; W2_29[1]=17891;  W2_29[2]=-11090; W2_29[3]=22342;  W2_29[4]=-20389; W2_29[5]=-6249;  W2_29[6]=-320;   W2_29[7]=22365;
        W2_29[8]=8523;   W2_29[9]=-9444;  W2_29[10]=18815; W2_29[11]=20507; W2_29[12]=-10284;W2_29[13]=17158; W2_29[14]=745;   W2_29[15]=-802;
        
        W2_30[0]=10072;  W2_30[1]=15937;  W2_30[2]=6363;   W2_30[3]=-21111; W2_30[4]=10910;  W2_30[5]=-106;   W2_30[6]=-9437;  W2_30[7]=-7768;
        W2_30[8]=-2915;  W2_30[9]=14997;  W2_30[10]=18038; W2_30[11]=-9433; W2_30[12]=14049; W2_30[13]=6882;  W2_30[14]=-9657; W2_30[15]=-15340;
        
        W2_31[0]=5430;   W2_31[1]=-3865;  W2_31[2]=9814;   W2_31[3]=-1478;  W2_31[4]=15370;  W2_31[5]=-5703;  W2_31[6]=19263;  W2_31[7]=14435;
        W2_31[8]=-10051; W2_31[9]=-14239; W2_31[10]=13838; W2_31[11]=12773; W2_31[12]=-16223;W2_31[13]=-7679; W2_31[14]=6888;  W2_31[15]=2139;
        
        // B2
        B2[0]=26616;  B2[1]=-21368; B2[2]=20809;  B2[3]=-2639;  B2[4]=3182;   B2[5]=-26385; B2[6]=-12019; B2[7]=3565;
        B2[8]=73154;  B2[9]=9128;   B2[10]=-33946;B2[11]=17736; B2[12]=-9883; B2[13]=20334; B2[14]=-6994; B2[15]=42980;
        
        // W3
        W3_0[0]=-29284;  W3_0[1]=22266;
        W3_1[0]=-10066;  W3_1[1]=31400;
        W3_2[0]=-85189;  W3_2[1]=-4824;
        W3_3[0]=-54797;  W3_3[1]=6855;
        W3_4[0]=67778;   W3_4[1]=3660;
        W3_5[0]=33851;   W3_5[1]=3800;
        W3_6[0]=-27119;  W3_6[1]=3393;
        W3_7[0]=-53534;  W3_7[1]=-36600;
        W3_8[0]=-56222;  W3_8[1]=60012;
        W3_9[0]=1073;    W3_9[1]=-5173;
        W3_10[0]=15458;  W3_10[1]=-32361;
        W3_11[0]=-76585; W3_11[1]=14205;
        W3_12[0]=22234;  W3_12[1]=25999;
        W3_13[0]=63604;  W3_13[1]=883;
        W3_14[0]=-25959; W3_14[1]=32549;
        W3_15[0]=1703;   W3_15[1]=44875;
        
        // B3
        B3[0]=66792;
        B3[1]=6553;
    end
    
    // ========================================
    // Pipeline регистры
    // ========================================
    reg signed [31:0] input_norm [0:5];
    reg signed [31:0] layer1_z   [0:31];
    reg signed [31:0] layer1_a   [0:31];
    reg signed [31:0] layer2_z   [0:15];
    reg signed [31:0] layer2_a   [0:15];
    reg signed [31:0] layer3_z   [0:1];
    
    // Временные переменные для вычислений
    reg signed [63:0] temp_prod;
    reg signed [63:0] temp_acc;
    integer i;
    
    // ========================================
    // FSM переходы
    // ========================================
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            IDLE:       if (start) next_state = NORMALIZE;
            NORMALIZE:  next_state = COMPUTE_L1;
            COMPUTE_L1: next_state = RELU_L1;
            RELU_L1:    next_state = COMPUTE_L2;
            COMPUTE_L2: next_state = RELU_L2;
            RELU_L2:    next_state = COMPUTE_L3;
            COMPUTE_L3: next_state = DENORM;
            DENORM:     next_state = DONE;
            DONE:       next_state = IDLE;
            default:    next_state = IDLE;
        endcase
    end
    
    // ========================================
    // FSM логика обработки
    // ========================================
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            valid_out <= 1'b0;
            m_out <= 32'sd0;
            b_out <= 32'sd0;
            for (i = 0; i < 6; i = i + 1) input_norm[i] <= 32'sd0;
            for (i = 0; i < 32; i = i + 1) begin
                layer1_z[i] <= 32'sd0;
                layer1_a[i] <= 32'sd0;
            end
            for (i = 0; i < 16; i = i + 1) begin
                layer2_z[i] <= 32'sd0;
                layer2_a[i] <= 32'sd0;
            end
            layer3_z[0] <= 32'sd0;
            layer3_z[1] <= 32'sd0;
        end else begin
            valid_out <= 1'b0;
            
            case (state)
                NORMALIZE: begin
                    // Нормализация: 2*(val-min)/(max-min) - 1
                    // X: min=-1000000, max=1000000, range=2000000
                    // Y: min=4500000, max=5500000, range=1000000
                    input_norm[0] <= normalize_x(x1);
                    input_norm[1] <= normalize_y(y1);
                    input_norm[2] <= normalize_x(x2);
                    input_norm[3] <= normalize_y(y2);
                    input_norm[4] <= normalize_x(x3);
                    input_norm[5] <= normalize_y(y3);
                end
                
                COMPUTE_L1: begin
                    // Layer 1: вычисляем все 32 нейрона
                    for (i = 0; i < 32; i = i + 1) begin
                        layer1_z[i] <= compute_neuron_l1(i);
                    end
                end
                
                RELU_L1: begin
                    for (i = 0; i < 32; i = i + 1) begin
                        layer1_a[i] <= (layer1_z[i][31]) ? 32'sd0 : layer1_z[i];
                    end
                end
                
                COMPUTE_L2: begin
                    for (i = 0; i < 16; i = i + 1) begin
                        layer2_z[i] <= compute_neuron_l2(i);
                    end
                end
                
                RELU_L2: begin
                    for (i = 0; i < 16; i = i + 1) begin
                        layer2_a[i] <= (layer2_z[i][31]) ? 32'sd0 : layer2_z[i];
                    end
                end
                
                COMPUTE_L3: begin
                    layer3_z[0] <= compute_neuron_l3(0);
                    layer3_z[1] <= compute_neuron_l3(1);
                end
                
                DENORM: begin
                    // Денормализация: (val+1)/2 * (max-min) + min
                    // MB: min=-500000, max=500000, range=1000000
                    m_out <= denormalize_mb(layer3_z[0]);
                    b_out <= denormalize_mb(layer3_z[1]);
                end
                
                DONE: begin
                    valid_out <= 1'b1;
                end
            endcase
        end
    end
    
        // ========================================
    // Функция нормализации X
    // normalize(val, -10, 10) = 2*(val+10)/20 - 1
    // В fixed point: (val_fp + 1000000)/10 - 100000
    // ========================================
    function signed [31:0] normalize_x;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = $signed(val) + 64'sd1000000;
            temp = temp / 64'sd10;
            temp = temp - 64'sd100000;
            normalize_x = temp[31:0];
        end
    endfunction
    
    // ========================================
    // Функция нормализации Y
    // normalize(val, 45, 55) = 2*(val-45)/10 - 1
    // В fixed point: (val_fp - 4500000)/5 - 100000
    // ========================================
    function signed [31:0] normalize_y;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = $signed(val) - 64'sd4500000;
            temp = temp / 64'sd5;
            temp = temp - 64'sd100000;
            normalize_y = temp[31:0];
        end
    endfunction
    
    // ========================================
    // Функция денормализации MB
    // denormalize(val, -5, 5) = (val+1)/2 * 10 - 5
    // В fixed point: (val_fp + 100000) * 5 - 500000
    // ========================================
    function signed [31:0] denormalize_mb;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = $signed(val) + 64'sd100000;
            temp = temp * 64'sd5;
            temp = temp - 64'sd500000;
            denormalize_mb = temp[31:0];
        end
    endfunction
    
    // ========================================
    // Вычисление нейрона Layer 1
    // ========================================
    function signed [31:0] compute_neuron_l1;
        input integer idx;
        reg signed [63:0] acc;
        reg signed [63:0] prod;
        begin
            acc = 0;
            
            // Умножаем и делим на SCALE
            prod = input_norm[0] * $signed(W1_0[idx]); acc = acc + (prod / SCALE);
            prod = input_norm[1] * $signed(W1_1[idx]); acc = acc + (prod / SCALE);
            prod = input_norm[2] * $signed(W1_2[idx]); acc = acc + (prod / SCALE);
            prod = input_norm[3] * $signed(W1_3[idx]); acc = acc + (prod / SCALE);
            prod = input_norm[4] * $signed(W1_4[idx]); acc = acc + (prod / SCALE);
            prod = input_norm[5] * $signed(W1_5[idx]); acc = acc + (prod / SCALE);
            
            acc = acc + $signed(B1[idx]);
            compute_neuron_l1 = acc[31:0];
        end
    endfunction
    
    // ========================================
    // Вычисление нейрона Layer 2
    // ========================================
    function signed [31:0] compute_neuron_l2;
        input integer idx;
        reg signed [63:0] acc;
        reg signed [63:0] prod;
        begin
            acc = 0;
            
            prod = layer1_a[0]  * $signed(W2_0[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[1]  * $signed(W2_1[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[2]  * $signed(W2_2[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[3]  * $signed(W2_3[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[4]  * $signed(W2_4[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[5]  * $signed(W2_5[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[6]  * $signed(W2_6[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[7]  * $signed(W2_7[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[8]  * $signed(W2_8[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[9]  * $signed(W2_9[idx]);  acc = acc + (prod / SCALE);
            prod = layer1_a[10] * $signed(W2_10[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[11] * $signed(W2_11[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[12] * $signed(W2_12[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[13] * $signed(W2_13[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[14] * $signed(W2_14[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[15] * $signed(W2_15[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[16] * $signed(W2_16[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[17] * $signed(W2_17[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[18] * $signed(W2_18[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[19] * $signed(W2_19[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[20] * $signed(W2_20[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[21] * $signed(W2_21[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[22] * $signed(W2_22[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[23] * $signed(W2_23[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[24] * $signed(W2_24[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[25] * $signed(W2_25[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[26] * $signed(W2_26[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[27] * $signed(W2_27[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[28] * $signed(W2_28[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[29] * $signed(W2_29[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[30] * $signed(W2_30[idx]); acc = acc + (prod / SCALE);
            prod = layer1_a[31] * $signed(W2_31[idx]); acc = acc + (prod / SCALE);
            
            acc = acc + $signed(B2[idx]);
            compute_neuron_l2 = acc[31:0];
        end
    endfunction
    
    // ========================================
    // Вычисление нейрона Layer 3
    // ========================================
    function signed [31:0] compute_neuron_l3;
        input integer idx;
        reg signed [63:0] acc;
        reg signed [63:0] prod;
        begin
            acc = 0;
            
            prod = layer2_a[0]  * $signed(W3_0[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[1]  * $signed(W3_1[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[2]  * $signed(W3_2[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[3]  * $signed(W3_3[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[4]  * $signed(W3_4[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[5]  * $signed(W3_5[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[6]  * $signed(W3_6[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[7]  * $signed(W3_7[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[8]  * $signed(W3_8[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[9]  * $signed(W3_9[idx]);  acc = acc + (prod / SCALE);
            prod = layer2_a[10] * $signed(W3_10[idx]); acc = acc + (prod / SCALE);
            prod = layer2_a[11] * $signed(W3_11[idx]); acc = acc + (prod / SCALE);
            prod = layer2_a[12] * $signed(W3_12[idx]); acc = acc + (prod / SCALE);
            prod = layer2_a[13] * $signed(W3_13[idx]); acc = acc + (prod / SCALE);
            prod = layer2_a[14] * $signed(W3_14[idx]); acc = acc + (prod / SCALE);
            prod = layer2_a[15] * $signed(W3_15[idx]); acc = acc + (prod / SCALE);
            
            acc = acc + $signed(B3[idx]);
            compute_neuron_l3 = acc[31:0];
        end
    endfunction

endmodule
```

### Тестовый модуль

```
/*
 * Testbench для neural_inference (Verilog 2001)
 */

`timescale 1ns / 1ps

module tb_neural_inference;

    parameter SCALE = 100000;
    parameter CLK_PERIOD = 10;
    
    reg clk;
    reg rst;
    reg start;
    reg signed [31:0] x1, y1, x2, y2, x3, y3;
    wire signed [31:0] m_out, b_out;
    wire valid_out;
    
    // Инстанцирование DUT
    neural_inference #(
        .SCALE(SCALE)
    ) dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .x1(x1), .y1(y1),
        .x2(x2), .y2(y2),
        .x3(x3), .y3(y3),
        .m_out(m_out),
        .b_out(b_out),
        .valid_out(valid_out)
    );
    
    // Генератор тактов
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    // Основной тест
    initial begin
        $display("========================================");
        $display("  Neural Network Inference Test");
        $display("  Architecture: 6 -> 32 -> 16 -> 2");
        $display("  Scale: %0d", SCALE);
        $display("========================================\n");
        
        // Инициализация
        rst = 1;
        start = 0;
        x1 = 0; y1 = 0;
        x2 = 0; y2 = 0;
        x3 = 0; y3 = 0;
        
        repeat(5) @(posedge clk);
        rst = 0;
        repeat(2) @(posedge clk);
        
        // ===========================
        // ТЕСТ 1: y = 2x + 1
        // ===========================
        $display("\n[TEST 1] y = 2x + 1");
        $display("Points: (1.0, 3.0), (2.0, 5.0), (3.0, 7.0)");
        
        @(posedge clk);
        x1 = 32'sd100000;  // 1.0
        y1 = 32'sd300000;  // 3.0
        x2 = 32'sd200000;  // 2.0
        y2 = 32'sd500000;  // 5.0
        x3 = 32'sd300000;  // 3.0
        y3 = 32'sd700000;  // 7.0
        
        start = 1;
        @(posedge clk);
        start = 0;
        
        wait(valid_out);
        @(posedge clk);
        
        $display("Expected: m = 2.0000, b = 1.0000");
        $display("Got:      m = %f, b = %f", 
                 $itor(m_out)/SCALE, $itor(b_out)/SCALE);
        
        repeat(10) @(posedge clk);
        
        // ===========================
        // ТЕСТ 2: y = -1.5x + 2
        // ===========================
        $display("\n[TEST 2] y = -1.5x + 2");
        $display("Points: (0.0, 2.0), (2.0, -1.0), (4.0, -4.0)");
        
        @(posedge clk);
        x1 = 32'sd0;        // 0.0
        y1 = 32'sd200000;   // 2.0
        x2 = 32'sd200000;   // 2.0
        y2 = -32'sd100000;  // -1.0
        x3 = 32'sd400000;   // 4.0
        y3 = -32'sd400000;  // -4.0
        
        start = 1;
        @(posedge clk);
        start = 0;
        
        wait(valid_out);
        @(posedge clk);
        
        $display("Expected: m = -1.5000, b = 2.0000");
        $display("Got:      m = %f, b = %f", 
                 $itor(m_out)/SCALE, $itor(b_out)/SCALE);
        
        repeat(10) @(posedge clk);
        
        // ===========================
        // ТЕСТ 3: y = 0.5x + 0.5
        // ===========================
        $display("\n[TEST 3] y = 0.5x + 0.5");
        $display("Points: (-1.0, 0.0), (1.0, 1.0), (3.0, 2.0)");
        
        @(posedge clk);
        x1 = -32'sd100000;  // -1.0
        y1 = 32'sd0;        // 0.0
        x2 = 32'sd100000;   // 1.0
        y2 = 32'sd100000;   // 1.0
        x3 = 32'sd300000;   // 3.0
        y3 = 32'sd200000;   // 2.0
        
        start = 1;
        @(posedge clk);
        start = 0;
        
        wait(valid_out);
        @(posedge clk);
        
        $display("Expected: m = 0.5000, b = 0.5000");
        $display("Got:      m = %f, b = %f", 
                 $itor(m_out)/SCALE, $itor(b_out)/SCALE);
        
        repeat(10) @(posedge clk);
        
        // ===========================
        // Завершение
        // ===========================
        $display("\n========================================");
        $display("  All tests completed!");
        $display("========================================\n");
        
        //#1000;
        $finish;
    end
    
    // Таймаут
    initial begin
        #100000;
        $display("\nERROR: Simulation timeout!");
        $finish;
    end
    
    // VCD dump
    initial begin
        $dumpfile("tb_neural_inference.vcd");
        $dumpvars(0, tb_neural_inference);
    end

endmodule
```

## Этап 3. Разделение и первая оптимизация
Синтез полученного кода на Verilog показал, что для реализации модуля на ПЛИС потребовало бы прмерно 1,5 миллиона LUTов и все 240 DSP. Для начала было проведено разделение одного файла на несколько разных файлов для удобства разработки.
### Заголовочный файл
Ниже представлен код заголовочного файла с константами.
```verilog
// =============================================================================
// neural_weights.vh
//
// Этот файл содержит веса, смещения и константы
// для модуля нейронной сети neural_inference.
//
// Архитектура: 6 -> 32 -> 16 -> 2
// Веса получены из ПР№1 (масштаб: SCALE)
// =============================================================================

// ========================================
// Константы нормализации (в формате fixed-point)
// ========================================
// X_MIN=-10.0, X_MAX= 10.0 => Диапазон 20.0
// Y_MIN= 45.0, Y_MAX= 55.0 => Диапазон 10.0
// MB_MIN=-5.0, MB_MAX=  5.0 => Диапазон 10.0
parameter signed [31:0] X_MIN_FP  = -10 * SCALE;
parameter signed [31:0] X_MAX_FP  =  10 * SCALE;
parameter signed [31:0] Y_MIN_FP  =  45 * SCALE;
parameter signed [31:0] Y_MAX_FP  =  55 * SCALE;
parameter signed [31:0] MB_MIN_FP =  -5 * SCALE;
parameter signed [31:0] MB_MAX_FP =   5 * SCALE;
```
### Генератор HEX-весов
Дальше нужно вывести отдельно веса в mem-файл, для этого был составлен скрипт на языке Python, который вычисляет веса и генерирует mem-файлы. Затем mem-файлы импортируются в проект.
```python
import numpy as np
import os
import sys

# =============================================================================
# 1. КОНФИГУРАЦИЯ
# =============================================================================

# -- Архитектура сети --
NUM_POINTS = 3
INPUT_SIZE = NUM_POINTS * 2  # 6
HIDDEN1_SIZE = 32
HIDDEN2_SIZE = 16
OUTPUT_SIZE = 2 # (m, b)

# -- Параметры обучения (должны совпадать с C++) --
LEARNING_RATE = 0.001
STEPS = 80000
BATCH_SIZE = 128

# -- Диапазоны для генерации данных и нормализации (должны совпадать с C++) --
M_B_MIN = -5.0
M_B_MAX = 5.0
X_MIN = -10.0
X_MAX = 10.0

# ВНИМАНИЕ: Диапазон Y в C++ коде был рассчитан как Y_MIN=45.0, Y_MAX=55.0.
# Это асимметричный диапазон, но мы будем его использовать для точного воспроизведения
# результатов C++ кода. Фактический диапазон y = m*x+b находится в пределах [-55, 55].
# Y_MIN = M_B_MIN * X_MIN + M_B_MIN  # (-5)*(-10)+(-5) = 45
# Y_MAX = M_B_MAX * X_MAX + M_B_MAX  # (5)*(10)+(5)   = 55
Y_MIN = 45.0
Y_MAX = 55.0

# -- Параметры квантизации --
SCALE_FACTOR = 100000

# =============================================================================
# 2. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
# =============================================================================

def glorot_initializer(rows, cols, seed):
    """
    Инициализация весов методом Glorot (Xavier), точно как в C++ коде.
    """
    rng = np.random.RandomState(seed)
    limit = np.sqrt(6.0 / (rows + cols)) # Более стандартный предел для uniform
    # C++ код использовал std::sqrt(2.0/(r+c)) с uniform(-1,1), что ближе к He,
    # но для воспроизводимости мы будем придерживаться той же логики.
    # Чтобы точно соответствовать C++, мы используем их формулу.
    scale = np.sqrt(2.0 / (rows + cols))
    return rng.uniform(low=-1.0, high=1.0, size=(rows, cols)) * scale

def relu(x):
    """Функция активации ReLU."""
    return np.maximum(0, x)

def relu_derivative(x):
    """Производная ReLU."""
    return np.where(x > 0, 1.0, 0.0)

def normalize(val, min_val, max_val):
    """Нормализация значения в диапазон [-1, 1]."""
    return 2.0 * (val - min_val) / (max_val - min_val) - 1.0

def quantize_and_save_hex(matrix, filename):
    """
    Квантует матрицу, преобразует в 32-битный 2's complement HEX
    и сохраняет в файл.
    """
    # Verilog BRAM ожидает одномерный массив.
    # .flatten() по умолчанию использует C-style (row-major), что нам и нужно.
    flat_matrix = matrix.flatten()
    
    quantized_values = np.round(flat_matrix * SCALE_FACTOR).astype(np.int64)
    
    with open(filename, 'w') as f:
        f.write(f"// Матрица формы: {matrix.shape}\n")
        f.write(f"// Сохранено в row-major порядке для $readmemh\n")
        for val in quantized_values:
            # Преобразование в 32-битное беззнаковое для корректного hex
            hex_val = format(val & 0xFFFFFFFF, '08x')
            f.write(hex_val + '\n')
    print(f"Сохранен файл: {filename} ({len(quantized_values)} значений)")

# =============================================================================
# 3. ПРОЦЕСС ОБУЧЕНИЯ
# =============================================================================

def main():
    print("Инициализация весов...")
    # Используем те же seed, что и в C++
    W1 = glorot_initializer(INPUT_SIZE, HIDDEN1_SIZE, seed=1)
    B1 = glorot_initializer(1, HIDDEN1_SIZE, seed=2)
    W2 = glorot_initializer(HIDDEN1_SIZE, HIDDEN2_SIZE, seed=3)
    B2 = glorot_initializer(1, HIDDEN2_SIZE, seed=4)
    W3 = glorot_initializer(HIDDEN2_SIZE, OUTPUT_SIZE, seed=5)
    B3 = glorot_initializer(1, OUTPUT_SIZE, seed=6)

    # Генератор случайных чисел для данных
    data_rng = np.random.RandomState(1337)

    print("Начало обучения...")
    for step in range(STEPS):
        # --- Генерация батча ---
        X_batch = np.zeros((BATCH_SIZE, INPUT_SIZE))
        Y_batch = np.zeros((BATCH_SIZE, OUTPUT_SIZE))
        
        true_m = data_rng.uniform(M_B_MIN, M_B_MAX, BATCH_SIZE)
        true_b = data_rng.uniform(M_B_MIN, M_B_MAX, BATCH_SIZE)
        
        for i in range(BATCH_SIZE):
            for p in range(NUM_POINTS):
                x = data_rng.uniform(X_MIN, X_MAX)
                y = true_m[i] * x + true_b[i]
                X_batch[i, p*2 + 0] = normalize(x, X_MIN, X_MAX)
                X_batch[i, p*2 + 1] = normalize(y, Y_MIN, Y_MAX)
            
            Y_batch[i, 0] = normalize(true_m[i], M_B_MIN, M_B_MAX)
            Y_batch[i, 1] = normalize(true_b[i], M_B_MIN, M_B_MAX)

        # --- Прямое распространение (Forward Pass) ---
        Z1 = X_batch @ W1 + B1
        A1 = relu(Z1)
        Z2 = A1 @ W2 + B2
        A2 = relu(Z2)
        Z3 = A2 @ W3 + B3
        Y_pred = Z3 # Линейный выходной слой

        # --- Обратное распространение (Backward Pass) ---
        error = Y_pred - Y_batch
        
        dZ3 = error
        dW3 = A2.T @ dZ3
        dB3 = np.sum(dZ3, axis=0, keepdims=True)
        dA2 = dZ3 @ W3.T
        
        dZ2 = dA2 * relu_derivative(Z2)
        dW2 = A1.T @ dZ2
        dB2 = np.sum(dZ2, axis=0, keepdims=True)
        dA1 = dZ2 @ W2.T
        
        dZ1 = dA1 * relu_derivative(Z1)
        dW1 = X_batch.T @ dZ1
        dB1 = np.sum(dZ1, axis=0, keepdims=True)
        
        # --- Обновление весов ---
        N = BATCH_SIZE
        W1 -= LEARNING_RATE * dW1 / N
        B1 -= LEARNING_RATE * dB1 / N
        W2 -= LEARNING_RATE * dW2 / N
        B2 -= LEARNING_RATE * dB2 / N
        W3 -= LEARNING_RATE * dW3 / N
        B3 -= LEARNING_RATE * dB3 / N
        
        if step % 5000 == 0 or step == STEPS - 1:
            loss = np.mean(error**2)
            print(f"Шаг {step:5d}, Потери: {loss:.8f}")

    print("\nОбучение завершено. Квантизация и сохранение весов...")
    
    # Создаем папку для весов, если ее нет
    output_dir = "hex_weights"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # ВНИМАНИЕ: Для Verilog BRAM матрицы W1, W2, W3 нужно транспонировать
    # перед сохранением, если Verilog ожидает доступ [вход][нейрон].
    # Однако, доступ в Verilog коде `mac_idx * L_NEURONS + neuron_idx`
    # соответствует C-style row-major, поэтому транспонировать НЕ нужно.
    # Сохраняем как есть.
    
    quantize_and_save_hex(W1, os.path.join(output_dir, "w1.mem"))
    quantize_and_save_hex(B1, os.path.join(output_dir, "b1.mem"))
    quantize_and_save_hex(W2, os.path.join(output_dir, "w2.mem"))
    quantize_and_save_hex(B2, os.path.join(output_dir, "b2.mem"))
    quantize_and_save_hex(W3, os.path.join(output_dir, "w3.mem"))
    quantize_and_save_hex(B3, os.path.join(output_dir, "b3.mem"))
    
    print(f"\nВсе файлы сохранены в папку '{output_dir}'.")
    print("Теперь можно использовать эти файлы в Verilog-симуляции.")

if __name__ == '__main__':
    main()
```
### Модуль нейропроцессора
Ключевая проблема заключалась в примерно 700 умножителях, совершающие 64-битные операции. В результате оптимизации количество умножителей сократилось до 1. Ниже представлен оптимизированный код нейропроцессора на языке Verilog.
```verilog
/*
 * Нейронная сеть для inference (Verilog 2001) - ОПТИМИЗИРОВАННАЯ ВЕРСИЯ
 * Последовательная архитектура с одним MAC-блоком.
 */
module neural_inference_old1 #(
    parameter SCALE = 100000
)(
    input  wire clk,
    input  wire rst,
    input  wire start,
    
    input  wire signed [31:0] x1, y1,
    input  wire signed [31:0] x2, y2,
    input  wire signed [31:0] x3, y3,
    
    output reg  signed [31:0] m_out,
    output reg  signed [31:0] b_out,
    output reg  valid_out
);
    `include "neural_weights.vh" // Подключаем константы нормализации

    // ========================================
    // Параметры архитектуры
    // ========================================
    localparam L1_INPUTS = 6,  L1_NEURONS = 32;
    localparam L2_INPUTS = 32, L2_NEURONS = 16;
    localparam L3_INPUTS = 16, L3_NEURONS = 2;

    // ========================================
    // Состояния FSM
    // ========================================
    parameter [3:0] S_IDLE       = 4'd0;
    parameter [3:0] S_NORMALIZE  = 4'd1;
    // Layer 1
    parameter [3:0] S_L1_MAC_INIT  = 4'd2;
    parameter [3:0] S_L1_MAC_CYCLE = 4'd3;
    parameter [3:0] S_L1_BIAS_RELU = 4'd4;
    // Layer 2
    parameter [3:0] S_L2_MAC_INIT  = 4'd5;
    parameter [3:0] S_L2_MAC_CYCLE = 4'd6;
    parameter [3:0] S_L2_BIAS_RELU = 4'd7;
    // Layer 3
    parameter [3:0] S_L3_MAC_INIT  = 4'd8;
    parameter [3:0] S_L3_MAC_CYCLE = 4'd9;
    parameter [3:0] S_L3_BIAS_LINEAR = 4'd10; // Последний слой без ReLU
    // Output
    parameter [3:0] S_DENORM     = 4'd11;
    parameter [3:0] S_DONE       = 4'd12;
    
    reg [3:0] state, next_state;

    // ========================================
    // Счетчики для итераций
    // ========================================
    reg [5:0] neuron_idx; // Индекс текущего нейрона (max 32)
    reg [5:0] mac_idx;    // Индекс текущего входа/веса (max 32)

    // ========================================
    // Память для весов и смещений (BRAM)
    // ========================================
    reg signed [31:0] w1_bram [0:L1_INPUTS*L1_NEURONS-1];
    reg signed [31:0] b1_bram [0:L1_NEURONS-1];
    reg signed [31:0] w2_bram [0:L2_INPUTS*L2_NEURONS-1];
    reg signed [31:0] b2_bram [0:L2_NEURONS-1];
    reg signed [31:0] w3_bram [0:L3_INPUTS*L3_NEURONS-1];
    reg signed [31:0] b3_bram [0:L3_NEURONS-1];
    
    initial begin
    // Загрузка весов из файлов в BRAM
    $readmemh("w1.mem", w1_bram);
    $readmemh("b1.mem", b1_bram);
    $readmemh("w2.mem", w2_bram);
    $readmemh("b2.mem", b2_bram);
    $readmemh("w3.mem", w3_bram);
    $readmemh("b3.mem", b3_bram);
end

    // ========================================
    // Память для промежуточных активаций (BRAM/Distributed RAM)
    // ========================================
    reg signed [31:0] input_norm [0:L1_INPUTS-1];
    reg signed [31:0] layer1_a   [0:L1_NEURONS-1];
    reg signed [31:0] layer2_a   [0:L2_NEURONS-1];
    reg signed [31:0] layer3_z   [0:L3_NEURONS-1];

    // ========================================
    // Единый MAC блок (сердце оптимизации)
    // ========================================
    reg  signed [63:0] mac_acc;       // Аккумулятор
    wire signed [31:0] mac_in_a;      // Вход A (активация)
    wire signed [31:0] mac_in_b;      // Вход B (вес)
    wire signed [63:0] mac_prod;      // Произведение
    reg  signed [63:0] z_final;
    
    assign mac_prod = mac_in_a * mac_in_b;

    // ========================================
    // Мультиплексоры для выбора входов MAC
    // ========================================
    assign mac_in_a = (state == S_L1_MAC_CYCLE) ? input_norm[mac_idx] :
                      (state == S_L2_MAC_CYCLE) ? layer1_a[mac_idx] :
                      (state == S_L3_MAC_CYCLE) ? layer2_a[mac_idx] :
                      32'sd0;

    assign mac_in_b = (state == S_L1_MAC_CYCLE) ? w1_bram[mac_idx * L1_NEURONS + neuron_idx] :
                      (state == S_L2_MAC_CYCLE) ? w2_bram[mac_idx * L2_NEURONS + neuron_idx] :
                      (state == S_L3_MAC_CYCLE) ? w3_bram[mac_idx * L3_NEURONS + neuron_idx] :
                      32'sd0;

    // ========================================
    // FSM: Логика состояний
    // ========================================
    always @(posedge clk or posedge rst) begin
        if (rst) state <= S_IDLE;
        else     state <= next_state;
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            S_IDLE:       if (start) next_state = S_NORMALIZE;
            S_NORMALIZE:  next_state = S_L1_MAC_INIT;
            
            S_L1_MAC_INIT:  next_state = S_L1_MAC_CYCLE;
            S_L1_MAC_CYCLE: if (mac_idx == L1_INPUTS - 1) next_state = S_L1_BIAS_RELU;
                            else next_state = S_L1_MAC_CYCLE;
            S_L1_BIAS_RELU: if (neuron_idx == L1_NEURONS - 1) next_state = S_L2_MAC_INIT;
                            else next_state = S_L1_MAC_INIT;
            
            S_L2_MAC_INIT:  next_state = S_L2_MAC_CYCLE;
            S_L2_MAC_CYCLE: if (mac_idx == L2_INPUTS - 1) next_state = S_L2_BIAS_RELU;
                            else next_state = S_L2_MAC_CYCLE;
            S_L2_BIAS_RELU: if (neuron_idx == L2_NEURONS - 1) next_state = S_L3_MAC_INIT;
                            else next_state = S_L2_MAC_INIT;
            
            S_L3_MAC_INIT:  next_state = S_L3_MAC_CYCLE;
            S_L3_MAC_CYCLE: if (mac_idx == L3_INPUTS - 1) next_state = S_L3_BIAS_LINEAR;
                            else next_state = S_L3_MAC_CYCLE;
            S_L3_BIAS_LINEAR: if (neuron_idx == L3_NEURONS - 1) next_state = S_DENORM;
                              else next_state = S_L3_MAC_INIT;

            S_DENORM:     next_state = S_DONE;
            S_DONE:       next_state = S_IDLE;
            default:      next_state = S_IDLE;
        endcase
    end
    
    // ========================================
    // FSM: Логика вычислений и управления
    // ========================================
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            valid_out <= 1'b0; m_out <= 0; b_out <= 0;
            neuron_idx <= 0; mac_idx <= 0; mac_acc <= 0;
        end else begin
            valid_out <= 1'b0; // Сбрасывается по умолчанию
            case (state)
                S_IDLE: begin
                    neuron_idx <= 0;
                end
                S_NORMALIZE: begin
                    input_norm[0] <= normalize_x(x1);
                    input_norm[1] <= normalize_y(y1);
                    input_norm[2] <= normalize_x(x2);
                    input_norm[3] <= normalize_y(y2);
                    input_norm[4] <= normalize_x(x3);
                    input_norm[5] <= normalize_y(y3);
                end
                
                // --- Layer 1 ---
                S_L1_MAC_INIT: begin
                    mac_idx <= 0;
                    mac_acc <= 0;
                end
                S_L1_MAC_CYCLE: begin
                    mac_idx <= mac_idx + 1;
                    mac_acc <= mac_acc + mac_prod;
                end
                S_L1_BIAS_RELU: begin
                    neuron_idx <= neuron_idx + 1;
                    z_final = (mac_acc + mac_prod) / SCALE + b1_bram[neuron_idx];
                    if (z_final[63]) // ReLU
                        layer1_a[neuron_idx] <= 32'sd0;
                    else
                        layer1_a[neuron_idx] <= z_final[31:0];
                end
                
                // --- Layer 2 ---
                S_L2_MAC_INIT: begin
                    if (neuron_idx == L1_NEURONS - 1) neuron_idx <= 0; // Сброс счетчика для нового слоя
                    mac_idx <= 0;
                    mac_acc <= 0;
                end
                S_L2_MAC_CYCLE: begin
                    mac_idx <= mac_idx + 1;
                    mac_acc <= mac_acc + mac_prod;
                end
                S_L2_BIAS_RELU: begin
                    neuron_idx <= neuron_idx + 1;
                    z_final = (mac_acc + mac_prod) / SCALE + b2_bram[neuron_idx];
                    if (z_final[63]) // ReLU
                        layer2_a[neuron_idx] <= 32'sd0;
                    else
                        layer2_a[neuron_idx] <= z_final[31:0];
                end
                
                // --- Layer 3 ---
                S_L3_MAC_INIT: begin
                    if (neuron_idx == L2_NEURONS - 1) neuron_idx <= 0; // Сброс счетчика для нового слоя
                    mac_idx <= 0;
                    mac_acc <= 0;
                end
                S_L3_MAC_CYCLE: begin
                    mac_idx <= mac_idx + 1;
                    mac_acc <= mac_acc + mac_prod;
                end
                S_L3_BIAS_LINEAR: begin
                    neuron_idx <= neuron_idx + 1;
                    z_final = (mac_acc + mac_prod) / SCALE + b3_bram[neuron_idx];
                    layer3_z[neuron_idx] <= z_final[31:0];
                end
                
                S_DENORM: begin
                    m_out <= denormalize_mb(layer3_z[0]);
                    b_out <= denormalize_mb(layer3_z[1]);
                end
                S_DONE: begin
                    valid_out <= 1'b1;
                end
            endcase
        end
    end
    
    // ========================================
    // Функции нормализации (арифметика с фиксированной точкой)
    // ========================================
    function signed [31:0] normalize_x;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            // Формула: 2*(val - (-10))/(10 - (-10)) - 1  =>  (val + 10)/10 - 1
            temp = ($signed(val) + X_MIN_FP * -1) / 10 - SCALE;
            normalize_x = temp[31:0];
        end
    endfunction
    
    function signed [31:0] normalize_y;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            // Формула: 2*(val - 45)/(55 - 45) - 1  =>  (val - 45)/5 - 1
            temp = ($signed(val) - Y_MIN_FP) / 5 - SCALE;
            normalize_y = temp[31:0];
        end
    endfunction
    
    // ========================================
    // Функция денормализации (ИСПРАВЛЕНО)
    // ========================================
    function signed [31:0] denormalize_mb;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            // Формула: (val_f + 1.0) * 5.0 - 5.0
            // В fixed point: (val_fp + SCALE) * 5 + MB_MIN_FP
            temp = ($signed(val) + SCALE) * 5;
            temp = temp + MB_MIN_FP;
            denormalize_mb = temp[31:0];
        end
    endfunction

endmodule
```
### IP-ядро UART
Подробнее про IP-ядро UART будет рассказано в практической работе №3, но оно было вставлено для проверки возможности имплементации.
### Модуль верхнего уровня
Модуль верхнего уровня будет показан в практической работе №3, но он был составлен для проверки возможности имплементации.
### Файл проектных ограничений
Файл проектных ограничений будет показан в практической работе №3, но он был составлен для проверки возможности имплементации.
## Этап 4. Конвейеризация
Имплементация показала, что выполнение программы будет испытывать временные задержки по переднему фронту (Setup). Total Negative Slack составил примерно -100000 наносекунд, т.е. 0.1 милисекунд. Теоретически задержка вынуждает программе работать на частоте 1 кГц, что примерно в 10 раз медленнее, чем частота UART по стандарту RS-232 (9.6 кГц). Поэтому на нейропроцессоре был реализован 3-стадийный конвейер, который упорядочивает вычисления.
### Модуль нейропроцессора
Ниже представлен конвейеризированный код нейропроцессора на языке Verilog.
```verilog
/*
 * =====================================================================================
 * Модуль:          neural_inference_optimized
 * Версия:          2.0 (Конвейерная)
 * Описание:        Оптимизированная версия нейропроцессора с трехстадийным
 *                  конвейером (пайплайном) для решения критических проблем
 *                  с временными ограничениями (timing violations).
 *
 * Архитектурные изменения:
 * 1. MAC-блок (Multiply-Accumulate) разделен на 3 стадии:
 *    - Стадия 1 (READ):   Чтение операндов из памяти в регистры.
 *    - Стадия 2 (EXEC):   Выполнение умножения (на DSP блоке).
 *    - Стадия 3 (ACCUM):  Сложение результата умножения с аккумулятором.
 * 2. Деление на константу `SCALE` заменено на умножение на обратную величину
 *    с последующим сдвигом, что значительно быстрее для FPGA.
 *
 * Результат:       Дизайн может работать на высокой тактовой частоте (>100 МГц),
 *                  но общая задержка (latency) вычисления увеличивается.
 * =====================================================================================
 */
module neural_inference_old2 #(
    parameter SCALE = 100000
)(
    input  wire clk,
    input  wire rst,
    input  wire start,

    input  wire signed [31:0] x1, y1,
    input  wire signed [31:0] x2, y2,
    input  wire signed [31:0] x3, y3,
    
    output reg  signed [31:0] m_out,
    output reg  signed [31:0] b_out,
    output reg  valid_out
);

    `include "neural_weights.vh" // Подключаем только константы нормализации

    // ========================================
    // Параметры архитектуры и оптимизации
    // ========================================
    localparam L1_INPUTS = 6,  L1_NEURONS = 32;
    localparam L2_INPUTS = 32, L2_NEURONS = 16;
    localparam L3_INPUTS = 16, L3_NEURONS = 2;

    // Константа для замены деления: (1/SCALE) * 2^32
    // (1/100000) * 4294967296 = 42949.67... -> Округляем до 42950
    localparam signed [31:0] INV_SCALE = 32'd42950;

    // FSM Состояния (с добавлением стадий финализации)
    parameter [4:0] S_IDLE              = 5'd0;
    parameter [4:0] S_NORMALIZE         = 5'd1;
    parameter [4:0] S_L_MAC_INIT        = 5'd2;
    parameter [4:0] S_L_MAC_READ        = 5'd3;
    parameter [4:0] S_L_MAC_EXEC        = 5'd4;
    parameter [4:0] S_L_MAC_ACCUM       = 5'd5;
    // Новый конвейер финализации
    parameter [4:0] S_L_FIN_SCALE_MUL   = 5'd6; // Стадия 1: Умножение на INV_SCALE
    parameter [4:0] S_L_FIN_BIAS_ADD    = 5'd7; // Стадия 2: Добавление смещения
    parameter [4:0] S_L_FIN_RELU_WRITE  = 5'd8; // Стадия 3: ReLU и запись
    // Выходные состояния
    parameter [4:0] S_DENORM            = 5'd9;
    parameter [4:0] S_DONE              = 5'd10;
    
    reg [4:0] state = S_IDLE;
    reg [1:0] current_layer = 0; // 0: L1, 1: L2, 2: L3

    // ========================================
    // Счетчики
    // ========================================
    reg [5:0] neuron_idx; // Индекс текущего нейрона (max 32 -> 6 бит)
    reg [5:0] mac_idx;    // Индекс текущего входа/веса (max 32 -> 6 бит)

    // ========================================
    // Память для весов (BRAM)
    // ========================================
    reg signed [31:0] w1_bram [0:L1_INPUTS*L1_NEURONS-1];
    reg signed [31:0] b1_bram [0:L1_NEURONS-1];
    reg signed [31:0] w2_bram [0:L2_INPUTS*L2_NEURONS-1];
    reg signed [31:0] b2_bram [0:L2_NEURONS-1];
    reg signed [31:0] w3_bram [0:L3_INPUTS*L3_NEURONS-1];
    reg signed [31:0] b3_bram [0:L3_NEURONS-1];
    
    reg signed [64:0] temp_acc;
    reg signed [96:0] temp_mul; // 65 + 32 = 97
    reg signed [64:0] z_final;
    reg done;
    reg signed [31:0] bias;
    
    initial begin
        // Укажите правильные пути к вашим файлам
        $readmemh("w1.mem", w1_bram);
        $readmemh("b1.mem", b1_bram);
        $readmemh("w2.mem", w2_bram);
        $readmemh("b2.mem", b2_bram);
        $readmemh("w3.mem", w3_bram);
        $readmemh("b3.mem", b3_bram);
    end

    // ========================================
    // Память для активаций (Distributed RAM)
    // ========================================
    reg signed [31:0] input_norm [0:L1_INPUTS-1];
    reg signed [31:0] layer1_a   [0:L1_NEURONS-1];
    reg signed [31:0] layer2_a   [0:L2_NEURONS-1];
    reg signed [31:0] layer3_z   [0:L3_NEURONS-1];

    // Регистры конвейера
    reg  signed [31:0] mac_in_a_reg, mac_in_b_reg;
    reg  signed [63:0] mac_prod_reg;
    reg  signed [64:0] mac_acc;
    
    // Новые регистры для конвейера финализации
    reg  signed [96:0] scale_mul_reg; // Результат умножения на INV_SCALE
    reg  signed [64:0] z_final_reg;   // Результат после добавления смещения
    
    wire signed [31:0] mac_in_a_mux;      
    wire signed [31:0] mac_in_b_mux;      

    // Мультиплексоры для выбора источников данных (комбинационная логика)
    assign mac_in_a_mux = (current_layer == 0) ? input_norm[mac_idx] :
                          (current_layer == 1) ? layer1_a[mac_idx] :
                                                 layer2_a[mac_idx];

    assign mac_in_b_mux = (current_layer == 0) ? w1_bram[mac_idx * L1_NEURONS + neuron_idx] :
                          (current_layer == 1) ? w2_bram[mac_idx * L2_NEURONS + neuron_idx] :
                                                 w3_bram[mac_idx * L3_NEURONS + neuron_idx];
    
    // ========================================
    // Логика вычислений и управления
    // ========================================
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= S_IDLE;
            current_layer <= 0;
            valid_out <= 1'b0; m_out <= 0; b_out <= 0;
            neuron_idx <= 0; mac_idx <= 0;
            mac_in_a_reg <= 0; mac_in_b_reg <= 0;
            mac_prod_reg <= 0; mac_acc <= 0;
        end else begin
            valid_out <= 1'b0;

            // --- Безусловные операции конвейера ---
            // Стадия 2: Умножение. Результат будет готов на следующем такте в mac_prod_reg
            mac_prod_reg <= mac_in_a_reg * mac_in_b_reg;

            // --- Основной FSM ---
            case (state)
                S_IDLE: begin
                    if (start) begin
                        state <= S_NORMALIZE;
                    end
                end
                
                S_NORMALIZE: begin
                    input_norm[0] <= normalize_x(x1); input_norm[1] <= normalize_y(y1);
                    input_norm[2] <= normalize_x(x2); input_norm[3] <= normalize_y(y2);
                    input_norm[4] <= normalize_x(x3); input_norm[5] <= normalize_y(y3);
                    
                    state <= S_L_MAC_INIT;
                    current_layer <= 0; // Начинаем с 1-го слоя
                    neuron_idx <= 0;
                end

                S_L_MAC_INIT: begin
                    mac_acc <= 0;
                    mac_idx <= 0;
                    state <= S_L_MAC_READ;
                end
                
                S_L_MAC_READ: begin // Стадия 1
                    mac_in_a_reg <= mac_in_a_mux;
                    mac_in_b_reg <= mac_in_b_mux;
                    state <= S_L_MAC_EXEC;
                end

                S_L_MAC_EXEC: begin // Стадия 2
                    mac_idx <= mac_idx + 1;
                    state <= S_L_MAC_ACCUM;
                end

                S_L_MAC_ACCUM: begin // Стадия 3
                    mac_acc <= mac_acc + mac_prod_reg;
                    
                    // Проверяем, закончили ли мы MAC-операции для этого нейрона
                    if (current_layer == 0)      done = (mac_idx == L1_INPUTS); // ПРАВИЛЬНО
                    else if (current_layer == 1) done = (mac_idx == L2_INPUTS); // ПРАВИЛЬНО
                    else                         done = (mac_idx == L3_INPUTS); // ПРАВИЛЬНО

                    if (done) begin
                        state <= S_L_FIN_SCALE_MUL;
                    end else begin
                        state <= S_L_MAC_READ;
                    end
                end
                
                // --- НОВЫЙ КОНВЕЙЕР ФИНАЛИЗАЦИИ ---
                S_L_FIN_SCALE_MUL: begin // Стадия 1
                    scale_mul_reg <= mac_acc * INV_SCALE;
                    state <= S_L_FIN_BIAS_ADD;
                end

                S_L_FIN_BIAS_ADD: begin // Стадия 2
                    
                    if (current_layer == 0)      bias = b1_bram[neuron_idx];
                    else if (current_layer == 1) bias = b2_bram[neuron_idx];
                    else                         bias = b3_bram[neuron_idx];
                    z_final_reg <= (scale_mul_reg >> 32) + bias;
                    state <= S_L_FIN_RELU_WRITE;
                end

                S_L_FIN_RELU_WRITE: begin // Стадия 3
                    if (current_layer == 0) begin
                        if (z_final_reg[64]) layer1_a[neuron_idx] <= 0; else layer1_a[neuron_idx] <= z_final_reg[31:0];
                        if (neuron_idx == L1_NEURONS - 1) {current_layer, neuron_idx} <= {1'b1, 6'd0}; else neuron_idx <= neuron_idx + 1;
                        state <= S_L_MAC_INIT;
                    end else if (current_layer == 1) begin
                        if (z_final_reg[64]) layer2_a[neuron_idx] <= 0; else layer2_a[neuron_idx] <= z_final_reg[31:0];
                        if (neuron_idx == L2_NEURONS - 1) {current_layer, neuron_idx} <= {2'd2, 6'd0}; else neuron_idx <= neuron_idx + 1;
                        state <= S_L_MAC_INIT;
                    end else begin
                        layer3_z[neuron_idx] <= z_final_reg[31:0]; // Linear
                        if (neuron_idx == L3_NEURONS - 1) state <= S_DENORM;
                        else {neuron_idx, state} <= {neuron_idx + 1, S_L_MAC_INIT};
                    end
                end
                
                S_DENORM: {m_out, b_out, state} <= {denormalize_mb(layer3_z[0]), denormalize_mb(layer3_z[1]), S_DONE};
                S_DONE:   {valid_out, state} <= {1'b1, S_IDLE};
            endcase
        end
    end
    
    // ========================================
    // Функции нормализации/денормализации (без изменений)
    // ========================================
    function signed [31:0] normalize_x;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = ($signed(val) + X_MIN_FP * -1) / 10 - SCALE;
            normalize_x = temp[31:0];
        end
    endfunction
    
    function signed [31:0] normalize_y;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = ($signed(val) - Y_MIN_FP) / 5 - SCALE;
            normalize_y = temp[31:0];
        end
    endfunction
    
    function signed [31:0] denormalize_mb;
        input signed [31:0] val;
        reg signed [63:0] temp;
        begin
            temp = ($signed(val) + SCALE) * 5;
            temp = temp + MB_MIN_FP;
            denormalize_mb = temp[31:0];
        end
    endfunction

endmodule
```
